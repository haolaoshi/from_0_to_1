# from_0_to_1
#### 变量

* 变量的意义，方便管理内存空间，记住内存地址。
* 常量是记录程序中不可更改的数据 。

``` markdown
 常量定义有两种
  #define 宏常量
  const 常量
```

* float 4字节，double 8字节，默认小数只显示6位
* long型在win只有4字节，linux是8字节; 
* char只占1字节，char不是把自己放内存中，而是把ascii放入内存中。
* c风格字符串 chat str[] = “hello world“；

[这是go 五笔不骗你真的好用 ](https://www.cnblogs.com/nimeiz/p/5290785.html) 

* bool只有0表示false 其它值都是true

#### 数组与指针

* sizeof 统计数组内存长度，可算出数组元素个数。
* 指针就是一个地址，32位空间占4个字节。64 位空间占8字节。
* const 修饰指针叫常量指针，指向值不可以改，指向可以改。const int *p = &a;
* const 修饰常量，int * const p = &a; 指针常量，值可以改，指向不可以改
* 将形参改为指针，减少内存空间，但是会影响到外部；加const 避免误操作。
* 这是一个错误的拼接：p[i].name = "Student_" + str[i]; 这个加号并没有实现。

#### 内存模型


**内存分区**
1. `代码区`程序运行前分配的区域，二进制可执行程序。只读/共享
2. `全局区`全局变量和静态变量，程序运行前只有全局区和代码区。
3. `栈区`存放形参/局部变量，编译器自动分配，不要返回局部变量的地址。
4. `堆区` 函数可以返回堆区的地址，new返回的是地址。



* 引用必须要初始化， int &b = a; 一旦初始化后不可改变。
* 函数的引用传递，形参会修饰实参的，简化指针。效果跟地址传递是一样的。
* 函数的返回值是引用，是可以作为左值存在。test() = 1000
* 引用的本质是指针常量。编译器等同为 int *const ref = &a;
* const 修饰引用的形参，防止误操作。
* 函数重载（作用域，函数名，参数），`返回类型不算`。

#### 类

* C++面向对象三特性：封装
* 通过类创建对象，叫实例化
* 拷贝构造：const Person &p；不要利用拷贝构造初始化匿名对象。
* 拷贝构造用途：使用对象初始化新对象，值传递给函数，值返回局部对象。
* 类必须有三个函数：默认，析构和拷贝。
* 如果我们写了有参构造，编译不再提供无参构造，但会提供拷贝。
* 浅拷贝问题，堆区的内存释放；要利用深拷贝解决。
* 类对象作为类成员，构造顺序先进后出。先构造类中的属性对象，再构造自身。
* 空对象占用空间为1；
* 空指针可以访问成员，this==NULL 防御
* 友元：私有属性让类外的函数或类访问；全局函数/类/成员函数。成员函数作友元定义要放前面。

#### 高级知识

* 加号 运算符重载（成员函数，全局函数，）运算符重载可发生函数重载
* 左移运算符，由于无法实现左移运算符在左侧，所以不用成员运算符实现重载；为了能访问到类中的私有成员，把重载函数声明为友元函数。
* ++重载（前后++两个版本，前++要返回引用）,后置++需要占位参数区分前置，后置版本返回的是值，因为它是局部对象
* 赋值运算符是C++默认4个函数的最后一个。
* 继承
* 多态
* 文件操作
* 模板
* STL
* string
* vector
* stack
* queue
* list
* set
* map
* 函数对象
* 内建函数对象
* 遍历算法
* 查找算法
* 排序算法
* 拷贝替换算法
* 算术生成算法
* 集合算法
* 
 

 

 